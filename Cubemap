/* -*-c++-*- */


#ifndef CUBEMAP_H
#define CUBEMAP_H 1

#include "Math"
#include <string>

typedef unsigned int uint;
typedef struct tiff TIFF;

static Vec3f CubemapFace[6][3] = {
    { Vec3f(0,0,-1), Vec3f(0,-1,0), Vec3f(1,0,0) },// x positif
    { Vec3f(0,0,1), Vec3f(0,-1,0), Vec3f(-1,0,0) }, // x negatif

    { Vec3f(1,0,0), Vec3f(0,0,1), Vec3f(0,1,0) },  // y positif
    { Vec3f(1,0,0), Vec3f(0,0,-1),Vec3f(0,-1,0) }, // y negatif

    { Vec3f(1,0,0), Vec3f(0,-1,0), Vec3f(0,0,1) },  // z positif
    { Vec3f(-1,0,0), Vec3f(0,-1,0),Vec3f(0,0,-1) } // z negatif
};


struct Cubemap {

    struct MipLevel {
        int _size;
        float* _images[6];
    };


    int _size;
    float* _images[6];
    int _samplePerPixel;

    Cubemap* _normalizeSolidAngle;

    Cubemap();
    ~Cubemap();

    int getSize() const { return _size; }

    void fill( const Vec4f& value );
    void init( int size, int sample = 3);
    void write( const std::string& filename );
    void sample(const Vec3f& direction, Vec3f& color ) const;

    bool loadCubemap(const std::string& name);

    void buildNormalizerSolidAngleCubemap(int size, int fixupType);
    float texelCoordSolidAngle( int faceIndex, float u, float v);

    Cubemap* shFilterCubeMap(bool useSolidAngleWeighting, int fixupType, int outputCubemapSize = 256 );

    void fixupCubeEdges( const std::string& output, int level);


    void computePrefilteredEnvironmentUE4( const std::string& output, int startSize = 0, int startMipMap = 0, uint numSamples = 1024, bool fixup = false);
    void computeBackground( const std::string& output, int startSize, uint nbSamples, float roughnessLinear, const bool fixup );

    void computePrefilterCubemapAtLevel( float roughness, const Cubemap& inputCubemap, uint numSamples, bool fixup );
    void iterateOnFace( int face, float roughness, const Cubemap& cubemap, uint numSamples, bool fixup, bool backgroundAverage = false );
    void getSample(const Vec3f& direction, Vec3f& color ) const;

    Vec3f prefilterEnvMapUE4( float roughness, const Vec3f& R, uint numSamples ) const;
    Vec3f averageEnvMap( float roughnessLinear, const Vec3f& R, uint numSamples ) const;

    Cubemap* makeSeamless() const;


};

#endif
